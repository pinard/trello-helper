#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""\
Help communication between Trello site and Emacs Org files.
See https://github.com/pinard/trello-helper for details.

Usage: fetch-trello [OPTION] [BOARD]

Options:
  -d   Debug mode (embed IPython after connect).
  -i   Also include closed boards, lists and cards.
  -m   Transcribe Org inline markup to Markdown.

If no BOARD, create a board index.  Produce the Org file on standard output.
With -m, read text from standard input, load the result onto the clipboard.
"""

import sys
import os
import re

config_file = os.path.expanduser('~/.trello/config.ini')
encoding = 'UTF-8'

# See org-emphasis-regexp-components in org.el.  ('\n' added)
before_emphasis = ' \t\n(\'"{'
after_emphasis = '- \t\n.,:!?;\'")}\\'


class Main:
    debug = False
    include = False
    markdown = False

    def main(self, *arguments):

        # Decode options.
        import getopt
        options, arguments = getopt.getopt(arguments, 'dim')
        for option, value in options:
            if option == '-d':
                self.debug = True
            elif option == '-i':
                self.include = True
            elif option == '-m':
                self.markdown = True

        # Prepare UTF-8 output.
        import codecs
        self.write = codecs.getwriter(encoding)(sys.stdout).write

        # Specially handle the case of copying to the clipboard.
        if self.markdown:
            assert not arguments
            text = codecs.getreader(encoding)(sys.stdin).read()
            text = self.from_org(text)
            import pyperclip
            pyperclip.copy(text)
            return

        # Connect.
        from ConfigParser import ConfigParser
        parser = ConfigParser()
        parser.read(config_file)
        from trello import TrelloClient
        self.client = TrelloClient(parser.get('trello', 'key'),
                                   parser.get('trello', 'token'))

        # Use IPython to inspect when debugging.
        if self.debug:
            try:
                import IPython
                from IPython.config.loader import Config
            except ImportError:
                import pprint
                sys.displayhook = pprint.pprint

                import atexit, readline, rlcompleter
                readline.parse_and_bind('tab: complete')
                history = os.path.expanduser('~/.trello/debug-history')
                if os.path.exists(history):
                    readline.read_history_file(history)
                atexit.register(readline.write_history_file, history)

                del atexit, history, pprint, readline, rlcompleter
            else:
                config = Config()
                prompt = 'trello-helper'
                config.PromptManager.in_template = '%s [\\#]> ' % prompt
                config.PromptManager.out_template = '%s [\\#]: ' % prompt
                IPython.embed(config=config, user_ns={'self': self})
            return

        # Fetch Trello data and produce an Org file.
        if arguments:
            board = self.find_board(arguments[0].decode(encoding))
            self.copy_board(board)
        else:
            self.list_boards()

    def copy_board(self, board):
        self.write("#+TITLE: Trello board %s\n"
                   '#+STARTUP: overview\n'
                   % board.name.decode(encoding))
        for list in board.all_lists():
            if self.include or not list.closed:
                self.copy_list(list)

    def copy_card(self, card):
        card.fetch()
        try:
            date = card.create_date.strftime('%Y-%m-%d')
        except IndexError:
            date = None
        self.write_header(2, card.name.decode(encoding),
                          done=card.closed if self.include else None,
                          date=date, id=card.id, url=card.url)
        if card.description:
            self.write_item(card.description.rstrip())
        for checklist in card.checklists:
            self.copy_checklist(checklist)
        if card.comments:
            self.write_header(3, 'Comments')
            for comment in card.comments:
                self.copy_comment(comment)

    def copy_checklist(self, checklist):
        self.write_header(3, checklist.name, id=checklist.id)
        for item in checklist.items:
            self.write_item(item['name'], done=item['checked'], id=item['id'])

    def copy_comment(self, comment):
        self.write_item(comment['memberCreator']['username'],
                        date=comment['date'][:10], id=comment['id'])
        text = self.to_org(comment['data']['text'])
        text = ''.join(('  ' + line).rstrip()
                       for line in text.splitlines(True))
        if not text.endswith('\n'):
            text += '\n'
        self.write(text)

    def copy_list(self, list):
        self.write_header(1, list.name.decode(encoding),
                          done=list.closed if self.include else None,
                          id=list.id)
        for card in list.list_cards():
            if self.include or not card.closed:
                self.copy_card(card)

    def find_board(self, name):
        for board in self.client.list_boards():
            if board.name.decode(encoding) == name:
                return board
        sys.exit("No such board: %s" % name)

    def list_boards(self):
        self.write("#+TITLE: Trello board index\n"
                   '#+STARTUP: showall\n'
                   "* Trello boards\n")
        for board in self.client.list_boards():
            if self.include or not board.closed:
                self.write_item(board.name.decode(encoding),
                                done=board.closed if self.include else None,
                                id=board.id, url=board.url)

    def write_header(self, level, text,
                     date=None, done=None, id=None, url=None):
        self.write('*' * level + ' ')
        if done is not None:
            self.write(('TODO', 'DONE')[done] + ' ')
        self.write(self.to_org(text.lstrip()) + '\n')
        if id:
            self.write(':PROPERTIES:\n'
                       ':orgtrello-id: %s\n'
                       ':END:'
                       '\n'
                       % id)
        if date or url:
            if url:
                self.write('([[%s][Trello]])' % url)
            if date and url:
                self.write(' ')
            if date:
                self.write('[%s]' % date)
            self.write('\n')

    def write_item(self, text, date=None, done=None, id=None, url=None):
        self.write('- ')
        if done is not None:
            self.write('[%s] ' % ' X'[done])
        if url:
            self.write('[[%s][%s]]' % (url, self.to_org(text.lstrip())))
        else:
            self.write(self.to_org(text.lstrip()))
        if date:
            self.write(' [%s]' % date)
        if id:
            self.write(' :PROPERTIES: {"orgtrello-id":"%s"}' % id)
        self.write('\n')

    @staticmethod
    def from_org(text):
        fragments = []
        position = 0
        for match in re.finditer('([/*=~])([^ \t\n](.*?[^ \t\n])?)\\1',
                                  text):
            delimiter, inner, _ = match.groups()
            # Avoid this match outside proper Org context.
            if not (match.start() == 0
                    or text[match.start() - 1] in before_emphasis):
                continue
            if not (match.end() == len(text)
                    or text[match.end()] in after_emphasis):
                continue
            # Avoid some ambiguities on the Org side.
            if (delimiter + ' ') in inner:
                continue
            if (' ' + delimiter) in inner:
                continue
            # The translated delimiter is for Markdown.
            if delimiter == '/':
                translated = '*'
            elif delimiter == '*':
                translated = '**'
            else:
                count = 0
                for match2 in re.finditer('`+', inner):
                    count = max(count, len(match2.group()))
                translated = '`' * (count + 1)
            # OK, produce some Markdown.
            fragments.append(text[position:match.start()]
                             + translated + ' ' + inner + ' ' + translated)
            position = match.end()
        fragments.append(text[position:])
        text = ''.join(fragments)
        return text

    @staticmethod
    def to_org(text):
        # Process in-line markup, using quick and fuzzy heuristics.
        fragments = []
        position = 0
        for match in re.finditer('(_|\\*+|`+)( *)(.+?)( *)\\1', text):
            delimiter, white1, inner, white2 = match.groups()
            # Avoid this match outside proper Org context.
            if not (white1 or match.start() == 0
                    or text[match.start() - 1] in before_emphasis):
                continue
            if not (white2 or match.end() == len(text)
                    or text[match.end()] in after_emphasis):
                continue
            # The translated delimiter is for Org.
            if delimiter in ('_', '*'):
                translated = '/'
            elif delimiter == '**':
                translated = '*'
            else:
                translated = '='
            # Avoid some ambiguities on the Org side.
            if (translated + ' ') in inner:
                continue
            if (' ' + translated) in inner:
                continue
            # OK, produce Org markup.
            fragments.append(text[position:match.start()]
                             + translated + inner + translated)
            position = match.end()
        fragments.append(text[position:])
        text = ''.join(fragments)
        # Remove some extraneous whitespace.
        text = '\n'.join(line.rstrip() for line in text.split('\n'))
        text = re.sub('\n\n\n+', '\n\n', text)
        return text


run = Main()
main = run.main

if __name__ == '__main__':
    main(*sys.argv[1:])
