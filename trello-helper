#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""\
Help communication between Trello site and Emacs Org files.
See https://github.com/pinard/trello-helper for details.

Usage: fetch-trello [OPTION] [BOARD]

Options:
  -d   Debug mode (embed IPython after connect).
  -i   Also include closed boards, lists and cards.

If no BOARD, create a board index.  Produce the Org file on standard output.
"""

import sys
import os
import re

config_file = os.path.expanduser('~/.trello/config.ini')
encoding = 'UTF-8'


class Main:
    debug = False
    include = False

    def main(self, *arguments):

        # Decode options.
        import getopt
        options, arguments = getopt.getopt(arguments, 'di')
        for option, value in options:
            if option == '-d':
                self.debug = True
            elif option == '-i':
                self.include = True

        # Prepare UTF-8 output.
        import codecs
        self.write = codecs.getwriter(encoding)(sys.stdout).write

        # Connect.
        from ConfigParser import ConfigParser
        parser = ConfigParser()
        parser.read(config_file)
        from trello import TrelloClient
        self.client = TrelloClient(parser.get('trello', 'key'),
                                   parser.get('trello', 'token'))

        # Use IPython to inspect when debugging.
        if self.debug:
            try:
                import IPython
                from IPython.config.loader import Config
            except ImportError:
                import pprint
                sys.displayhook = pprint.pprint

                import atexit, readline, rlcompleter
                readline.parse_and_bind('tab: complete')
                history = os.path.expanduser('~/.trello/debug-history')
                if os.path.exists(history):
                    readline.read_history_file(history)
                atexit.register(readline.write_history_file, history)

                del atexit, history, pprint, readline, rlcompleter
            else:
                config = Config()
                prompt = 'trello-helper'
                config.PromptManager.in_template = '%s [\\#]> ' % prompt
                config.PromptManager.out_template = '%s [\\#]: ' % prompt
                IPython.embed(config=config, user_ns={'self': self})
            return

        # Fetch Trello data and produce an Org file.
        if arguments:
            board = self.find_board(arguments[0].decode(encoding))
            self.copy_board(board)
        else:
            self.list_boards()

    def copy_board(self, board):
        self.write("#+TITLE: Trello board %s\n"
                   '#+STARTUP: content\n'
                   % board.name.decode(encoding))
        for list in board.all_lists():
            if self.include or not list.closed:
                self.copy_list(list)

    def copy_card(self, card):
        card.fetch()
        try:
            date = card.create_date.strftime('%Y-%m-%d')
        except IndexError:
            date = None
        self.write_header(2, card.name.decode(encoding),
                          done=card.closed if self.include else None,
                          date=date, id=card.id, url=card.url)
        if card.description:
            self.write_item(card.description.rstrip())
        for checklist in card.checklists:
            self.copy_checklist(checklist)
        if card.comments:
            self.write_header(3, 'Comments')
            for comment in card.comments:
                self.copy_comment(comment)

    def copy_checklist(self, checklist):
        self.write_header(3, checklist.name, id=checklist.id)
        for item in checklist.items:
            self.write_item(item['name'], done=item['checked'], id=item['id'])

    def copy_comment(self, comment):
        self.write_item(comment['memberCreator']['username'],
                        date=comment['date'][:10], id=comment['id'])
        text = self.from_markdown(comment['data']['text'])
        text = ''.join(('  ' + line).rstrip()
                       for line in text.splitlines(True))
        if not text.endswith('\n'):
            text += '\n'
        self.write(text)

    def copy_list(self, list):
        self.write_header(1, list.name.decode(encoding),
                          done=list.closed if self.include else None,
                          id=list.id)
        for card in list.list_cards():
            if self.include or not card.closed:
                self.copy_card(card)

    def find_board(self, name):
        for board in self.client.list_boards():
            if board.name.decode(encoding) == name:
                return board
        sys.exit("No such board: %s" % name)

    def list_boards(self):
        self.write("#+TITLE: Trello board index\n"
                   '#+STARTUP: showall\n'
                   "* Trello boards\n")
        for board in self.client.list_boards():
            if self.include or not board.closed:
                self.write_item(board.name.decode(encoding),
                                done=board.closed if self.include else None,
                                id=board.id, url=board.url)

    def write_header(self, level, text,
                     date=None, done=None, id=None, url=None):
        self.write('*' * level + ' ')
        if done is not None:
            self.write(('TODO', 'DONE')[done] + ' ')
        self.write(self.from_markdown(text.lstrip()) + '\n')
        if id:
            self.write(':PROPERTIES:\n'
                       ':orgtrello-id: %s\n'
                       ':END:'
                       '\n'
                       % id)
        if date or url:
            if url:
                self.write('([[%s][Trello]])' % url)
            if date and url:
                self.write(' ')
            if date:
                self.write('[%s]' % date)
            self.write('\n')

    def write_item(self, text, date=None, done=None, id=None, url=None):
        self.write('- ')
        if done is not None:
            self.write('[%s] ' % ' X'[done])
        if url:
            self.write('[[%s][%s]]' % (url, self.from_markdown(text.lstrip())))
        else:
            self.write(self.from_markdown(text.lstrip()))
        if date:
            self.write(' [%s]' % date)
        if id:
            self.write(' :PROPERTIES: {"orgtrello-id":"%s"}' % id)
        self.write('\n')

    def from_markdown(self, text):
        # Process in-line markup, using quick and fuzzy heuristics.
        fragments = []
        position = 0
        for match in re.finditer('(_|\\*+|`+)( *)(.+?)( *)\\1', text):
            delimiter, white1, inner, white2 = match.groups()
            # See org-emphasis-regexp-components in org.el.
            if not (white1 or match.start() == 0
                    or text[match.start() - 1] in ' \t(\'"{'):
                continue
            if not (white2 or match.end() == len(text)
                    or text[match.end()] in '- \t.,:!?;\'")}\\'):
                continue
            # The translated delimiter is for Org.
            if delimiter in ('_', '*'):
                translated = '/'
            elif delimiter == '**':
                translated = '*'
            else:
                translated = '='
            # Avoid some ambiguities on the Org side.
            if (translated + ' ') in inner:
                continue
            if (' ' + translated) in inner:
                continue
            # OK, produce Org markup.
            fragments.append(text[position:match.start()]
                             + translated + inner + translated)
            position = match.end()
        fragments.append(text[position:])
        text = ''.join(fragments)
        # Remove some extraneous whitespace.
        text = '\n'.join(line.rstrip() for line in text.split('\n'))
        text = re.sub('\n\n\n+', '\n\n', text)
        return text


run = Main()
main = run.main

if __name__ == '__main__':
    main(*sys.argv[1:])
